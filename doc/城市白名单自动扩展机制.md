# 城市白名单自动扩展机制

## 🎯 设计目标

实现一个既能防止代理共享，又不影响用户正常使用的城市检测机制。

---

## 📋 核心逻辑

### **阶段1：城市白名单累积（< MAX_CITIES）**

在账户城市数未达到上限时，**允许自动扩展城市白名单**。

```
初始状态：账户城市 = {}

第1次访问：设备A从Tokyo访问
→ ✅ 允许，账户城市 = {Tokyo}

第2次访问：设备B从NewYork访问  
→ ✅ 允许，账户城市 = {Tokyo, NewYork}

第3次访问：设备A从London访问
→ ✅ 允许（自动扩展），账户城市 = {Tokyo, NewYork, London}

...依此类推，直到达到 MAX_CITIES
```

### **阶段2：城市白名单锁定（>= MAX_CITIES）**

达到上限后，**不再接受新城市**，只能在已有城市中使用。

```
当前状态：账户城市 = {Tokyo, NewYork, London, Paris, Berlin} (5/5)

设备A从Madrid访问
→ ❌ 拒绝（该城市非常用城市）
→ 错误提示：账户已达5个城市上限

设备A从Tokyo访问
→ ✅ 允许（Tokyo在白名单中）

设备B从NewYork访问
→ ✅ 允许（NewYork在白名单中）
```

---

## ⚙️ 配置参数

### **anti-share-config.js**
```javascript
export const ANTI_SHARE_CONFIG = {
  MAX_CITIES: 5,  // 账户最大城市数量（测试建议：3-5）
  // ...
};
```

### **建议值**
- **严格模式**: `MAX_CITIES = 3` （适合单人/固定地点使用）
- **标准模式**: `MAX_CITIES = 5` （适合偶尔出差/旅行）
- **宽松模式**: `MAX_CITIES = 10` （适合频繁旅行/多地办公）

---

## 🔍 检测规则对比

### **新设备检测**（检测1）
```
触发条件：添加新设备
检测维度：账户维度（整个账户的所有城市）

规则：
- 新设备 + 已有城市 → ✅ 允许
- 新设备 + 新城市 → ❌ 拒绝（可疑共享）

示例：
账户城市 = {Tokyo, NewYork}
设备C（新）从Paris访问 → ❌ 拒绝
设备C（新）从Tokyo访问 → ✅ 允许
```

### **已存在设备检测**（检测2）
```
触发条件：已存在设备访问新城市
检测维度：账户维度 + 城市数量

规则：
- 已有城市 → ✅ 允许（直接放行）
- 新城市 + 未达上限 → ✅ 允许（自动扩展）
- 新城市 + 已达上限 → ❌ 拒绝（非常用城市）

示例：
账户城市 = {Tokyo, NewYork, London} (3/5)
设备A从Paris访问 → ✅ 允许（自动扩展到4/5）

账户城市 = {Tokyo, NewYork, London, Paris, Berlin} (5/5)
设备A从Madrid访问 → ❌ 拒绝（已达上限）
```

---

## 📊 用户体验场景

### **场景1：正常使用（单地点）**
```
用户在Tokyo使用订阅
第1天：Tokyo → ✅ 城市 = {Tokyo} (1/5)
第2天：Tokyo → ✅ 继续使用

结果：用户体验流畅，城市白名单仅包含Tokyo
```

### **场景2：出差旅行**
```
用户在Tokyo激活订阅
第1天：Tokyo → ✅ 城市 = {Tokyo} (1/5)
第3天：出差到NewYork → ✅ 城市 = {Tokyo, NewYork} (2/5)
第7天：回到Tokyo → ✅ 继续使用
第10天：旅行到London → ✅ 城市 = {Tokyo, NewYork, London} (3/5)

结果：自动累积城市白名单，不影响正常使用
```

### **场景3：频繁移动（达到上限）**
```
用户频繁出差
第1周：Tokyo, NewYork, London, Paris, Berlin
城市白名单 = {Tokyo, NewYork, London, Paris, Berlin} (5/5)

第2周：在Madrid尝试访问
→ ❌ 拒绝（该城市非常用城市）
→ 提示：账户已达5个城市上限

解决方案：
1. 关闭代理，使用已有城市
2. 联系服务商增加城市配额
```

### **场景4：代理共享检测**
```
用户A在Tokyo激活订阅
朋友B尝试在Madrid使用

如果朋友用新设备：
→ ❌ 拒绝（新设备+新城市）

如果朋友知道设备ID，用已有设备：
→ 如果未达上限：✅ 允许（但会占用城市配额）
→ 如果已达上限：❌ 拒绝（非常用城市）

结果：有效拦截大部分共享行为
```

---

## 🛠️ 实现细节

### **代码位置**
`i:\repo\test\MiSub\functions\[[path]].js`

### **核心逻辑**（第2056-2107行）
```javascript
// 【检测2】已存在设备的城市变化检测（账户维度 + 城市白名单自动扩展）
if (shouldCheckCity && isNewCity && !isNewDevice) {
    // 1. 获取账户所有城市
    const allCityKeysSet = new Set();
    Object.values(userData.devices).forEach(dev => {
        Object.values(dev.cities).forEach(cityInfo => {
            allCityKeysSet.add(cityInfo.city.toLowerCase());
        });
    });
    
    // 2. 如果城市已存在，直接允许
    if (allCityKeysSet.has(cityKey)) {
        // 放行
    } else {
        // 3. 城市不存在，检查是否达到上限
        const currentCityCount = allCityKeysSet.size;
        const maxCities = config.antiShare.MAX_CITIES || 5;
        
        if (currentCityCount >= maxCities) {
            // 已达上限，拒绝
            return { allowed: false, reason: 'existing_device_new_city' };
        }
        // 未达上限，允许自动扩展
        console.log(`[AntiShare] City whitelist expanding: ${city}`);
    }
}
```

### **错误提示**（第1900-1910行）
```javascript
function generateExistingDeviceNewCityError(deviceId, existingCities, newCity, cityCount, maxCities) {
    const errorNodes = [
        '🌍 该城市非常用城市',
        `账户已有城市 (${cityCount}/${maxCities}): ${cityList}`,
        `当前城市: ${newCity}`,
        '❌ 请使用常用节点或关闭代理后重试',
        '如持续出现此提示，请联系服务商'
    ];
    return errorNodes.join('\n');
}
```

---

## 📋 测试清单

### **基础测试**
- [ ] 1. 第1次访问：Tokyo → 城市 = {Tokyo} (1/5)
- [ ] 2. 第2次访问：Tokyo → 继续使用（不增加城市）
- [ ] 3. 第3次访问：NewYork → 城市 = {Tokyo, NewYork} (2/5)
- [ ] 4. 第4次访问：Tokyo → 继续使用（已有城市）

### **城市累积测试**
- [ ] 5. 逐步添加城市：London, Paris, Berlin
- [ ] 6. 验证城市计数：5/5
- [ ] 7. 尝试添加第6个城市：Madrid → ❌ 拒绝

### **上限锁定测试**
- [ ] 8. 城市白名单已满（5/5）
- [ ] 9. 访问新城市 → ❌ 拒绝
- [ ] 10. 访问已有城市 → ✅ 允许
- [ ] 11. 检查错误提示：显示城市列表和数量

### **设备间移动测试**
- [ ] 12. 设备A在Tokyo，设备B在NewYork
- [ ] 13. 设备A访问NewYork → ✅ 允许（城市已存在）
- [ ] 14. 设备B访问Tokyo → ✅ 允许（城市已存在）

### **通知测试**
- [ ] 15. 城市扩展时：查看日志（控制台）
- [ ] 16. 城市拒绝时：收到Telegram"🌍 城市异常"通知
- [ ] 17. 通知内容包含：城市列表、数量、原因

---

## 🎯 最佳实践

### **配置建议**
1. **个人用户**: `MAX_CITIES = 3`（居住地+工作地+偶尔旅行）
2. **经常出差**: `MAX_CITIES = 5`（标准配置）
3. **国际业务**: `MAX_CITIES = 10`（宽松配置）

### **监控建议**
1. 定期检查账户的城市分布
2. 异常城市（非常见城市）应触发人工审核
3. 短时间内多个新城市应标记为可疑

### **用户沟通**
1. 在激活通知中说明城市限制政策
2. 达到上限时，提供清晰的升级/申诉途径
3. 考虑提供"城市白名单重置"功能（需人工审核）

---

## 📈 优化方向

### **未来可考虑的功能**
1. **城市过期机制**：超过N天未使用的城市自动移除
2. **城市优先级**：常用城市不可移除，偶尔使用的可被替换
3. **地理区域检测**：同一国家/地区的城市算作一个
4. **动态上限**：根据订阅等级调整MAX_CITIES

---

**创建日期**: 2025/11/10  
**版本**: 1.0  
**作者**: Cascade AI  
**适用版本**: MiSub v2.0+
